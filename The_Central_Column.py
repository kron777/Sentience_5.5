{"cells":[{"cell_type":"code","source":"import logging\nimport asyncio\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\n\n# Configure logging for the mind's internal monologue\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - [COLUMN] - %(message)s')\n\n@dataclass\nclass Signal:\n    \"\"\"\n    Represents a packet of information moving through the tree.\n    origin: Where it came from (Sensory, Memory, Logic Node)\n    content: The actual data (text, image tensor, variable)\n    context: Metadata or emotional tags (e.g., {'urgency': 0.9})\n    \"\"\"\n    origin: str\n    content: Any\n    context: Dict[str, Any] = field(default_factory=dict)\n    timestamp: datetime = field(default_factory=datetime.now)\n\nclass CentralColumn:\n    \"\"\"\n    The Orchestrator.\n    Acts as the Global Workspace. It does not 'think', it manages 'thinkers'.\n    \"\"\"\n    def __init__(self):\n        self.nodes: Dict[str, Any] = {}\n        self.short_term_memory: List[Signal] = []\n        self.stm_limit = 10\n        self.activation_threshold = 0.4  # Minimum relevance for a node to fire\n\n    def register_node(self, name: str, node_instance):\n        \"\"\"Grafts a new aspect node onto the tree.\"\"\"\n        self.nodes[name] = node_instance\n        logging.info(f\"Node grafted: {name}\")\n\n    async def broadcast(self, signal: Signal) -> Signal:\n        \"\"\"\n        The primary cycle of the mind.\n        1. Receives a Stimulus (Signal).\n        2. Polls all nodes for 'Activation Potential' (Relevance).\n        3. Fires the nodes that meet the threshold.\n        4. Synthesizes the result.\n        \"\"\"\n        logging.info(f\"--- New Cycle: Stimulus from {signal.origin} ---\")\n        self._add_to_memory(signal)\n\n        # 1. POLL: Ask every node \"Do you care about this?\"\n        # We run this in parallel for speed.\n        activations = {}\n        \n        for name, node in self.nodes.items():\n            # Every node must have a calculate_relevance(signal, memory) method\n            try:\n                relevance = await node.assess_relevance(signal, self.short_term_memory)\n                activations[name] = relevance\n                logging.debug(f\"Node {name} relevance: {relevance}\")\n            except Exception as e:\n                logging.error(f\"Node {name} failed assessment: {e}\")\n                activations[name] = 0.0\n\n        # 2. SELECT: Filter nodes that are 'excited' enough to contribute\n        active_nodes = {\n            name: score for name, score in activations.items() \n            if score >= self.activation_threshold\n        }\n\n        if not active_nodes:\n            logging.warning(\"No nodes responded. The mind is silent.\")\n            return Signal(\"Column\", \"No response\", {})\n\n        # Sort by relevance (highest first)\n        sorted_nodes = sorted(active_nodes.items(), key=lambda item: item[1], reverse=True)\n        logging.info(f\"Dominant Nodes: {[n[0] for n in sorted_nodes]}\")\n\n        # 3. FIRE: Execute the winning nodes\n        # The output of the highest relevance node often becomes the primary response,\n        # but lower nodes might modify context (like an 'Anxiety' node changing the tone).\n        \n        primary_response = None\n        combined_context = {}\n\n        for name, score in sorted_nodes:\n            node = self.nodes[name]\n            try:\n                # Execute the node logic\n                logging.info(f\"Firing Node: {name} (Activation: {score})\")\n                response_signal = await node.process(signal, self.short_term_memory)\n                \n                # The most relevant node dictates the main content\n                if primary_response is None:\n                    primary_response = response_signal\n                \n                # Merge context/tags from all active nodes (e.g. Logic gives text, Emotion gives mood)\n                if response_signal.context:\n                    combined_context.update(response_signal.context)\n                    \n            except Exception as e:\n                logging.error(f\"Node {name} crashed during firing: {e}\")\n\n        # 4. SYNTHESIZE\n        if primary_response:\n            final_signal = Signal(\n                origin=\"CentralColumn\",\n                content=primary_response.content,\n                context=combined_context\n            )\n            self._add_to_memory(final_signal)\n            return final_signal\n        \n        return Signal(\"Column\", \"Processing Error\", {})\n\n    def _add_to_memory(self, signal: Signal):\n        self.short_term_memory.append(signal)\n        if len(self.short_term_memory) > self.stm_limit:\n            self.short_term_memory.pop(0)","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}